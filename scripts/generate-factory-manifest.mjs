#!/usr/bin/env node

import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";
import url from "node:url";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, "..");
const fameRoot = path.join(repoRoot, "src", "naylence", "fame");
const manifestPath = path.join(fameRoot, "factory-manifest.ts");
const manifestDir = path.dirname(manifestPath);

const IGNORED_DIRECTORIES = new Set(["__tests__", "__mocks__", "node_modules", "dist"]);
const FACTORY_SUFFIX = "-factory.ts";

async function collectFactories(currentDir) {
  const entries = await fs.readdir(currentDir, { withFileTypes: true });
  const discovered = [];

  for (const entry of entries) {
    if (IGNORED_DIRECTORIES.has(entry.name)) {
      continue;
    }

    const entryPath = path.join(currentDir, entry.name);
    if (entry.isDirectory()) {
      const nested = await collectFactories(entryPath);
      discovered.push(...nested);
      continue;
    }

    if (!entry.isFile()) {
      continue;
    }

    if (!entry.name.endsWith(FACTORY_SUFFIX)) {
      continue;
    }

    if (entry.name.endsWith(".d.ts") || entry.name.includes(".test.") || entry.name.includes(".spec.")) {
      continue;
    }

    discovered.push(entryPath);
  }

  return discovered;
}

async function getFactoryModules(filePaths) {
  const filtered = [];

  await Promise.all(
    filePaths.map(async (filePath) => {
      const contents = await fs.readFile(filePath, "utf8");

      if (!contents.includes("FACTORY_META")) {
        return;
      }

      if (!/export\s+default\s+/u.test(contents)) {
        return;
      }

      filtered.push(filePath);
    })
  );

  filtered.sort((a, b) => a.localeCompare(b));
  return filtered;
}

function toImportPath(targetPath) {
  const relative = path.relative(manifestDir, targetPath).replace(/\\/g, "/");
  const base = relative.startsWith(".") ? relative : `./${relative}`;
  return base.replace(/\.ts$/, ".js");
}

function buildManifest(modules) {
  const header = [
    "/**",
    " * AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.",
    " * Generated by scripts/generate-factory-manifest.mjs",
    " *",
    " * Provides the list of advanced security factory modules for registration.",
    " */",
    "",
  ].join("\n");

  const list = JSON.stringify(modules, null, 2);

  const body = `
export const MODULES = ${list} as const;

export type FactoryModuleSpec = (typeof MODULES)[number];
`;

  return `${header}${body}`;
}

async function main() {
  const factoryFiles = await collectFactories(fameRoot);

  const uniqueFiles = Array.from(new Set(factoryFiles));
  const factoryModules = await getFactoryModules(uniqueFiles);

  const importSpecifiers = factoryModules.map(toImportPath);
  const manifestContents = buildManifest(importSpecifiers);

  await fs.mkdir(manifestDir, { recursive: true });
  await fs.writeFile(manifestPath, manifestContents, "utf8");

  process.stdout.write(
    `Generated factory manifest with ${importSpecifiers.length} entries at ${path.relative(repoRoot, manifestPath)}\n`
  );
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
